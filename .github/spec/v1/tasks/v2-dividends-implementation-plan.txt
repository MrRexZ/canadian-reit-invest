================================================================================
DIVIDEND DISTRIBUTION SYSTEM - IMPLEMENTATION PLAN
Canadian REIT Investment Platform
================================================================================

VERSION: 1.2 (UPDATED - Aligned with Investment Counter Refactoring)
DATE: October 28, 2025
STATUS: Planning Phase - Not Yet Implemented

CRITICAL UPDATE:
This plan has been updated to align with the investment counter refactoring
pattern (see investment-counter-refactor-plan.txt). The dividend tracking uses
a per-investment counter via InvestmentDividendCounter PDA, ensuring each
investment can receive multiple dividends with sequential counters (0, 1, 2...).

IMPORTANT: We do NOT reuse InvestorFundraiser PDA for dividend tracking because:
- Dividends are per-INVESTMENT, not per investor-fundraiser relationship
- An investor may have multiple investments in the same fundraiser
- Each investment needs its own independent dividend sequence
- Solana MCP expert recommends separate PDA for clearer separation of concerns

================================================================================
1. OVERVIEW
================================================================================

This document outlines the implementation plan for a dividend distribution
system that allows administrators to issue USDC dividend payments to investors
who hold tokenized REIT shares. The system tracks dividend payouts on-chain
via Solana PDAs and transfers USDC from admin wallets to investor wallets.

GOALS:
- Enable transparent, auditable dividend distributions
- Track dividend history per investor and investment
- Ensure secure, admin-only dividend issuance
- Prevent duplicate dividend payments
- Maintain proper accounting of cumulative dividends

================================================================================
2. CURRENT SYSTEM ARCHITECTURE
================================================================================

2.1 EXISTING STATE STRUCTURES (AFTER REFACTORING)
--------------------------------------------------
From anchor/programs/canadianreitinvest/src/state.rs:

Fundraiser PDA:
- Seeds: [b"fundraiser", reit_id_hash]
- Stores: admin, usdc_mint, reit_mint, escrow_vault, total_raised, etc.

Investor PDA:
- Seeds: [b"investor", investor_pubkey]
- Stores: investor_pubkey, bump
- Note: investment_counter field removed in refactoring

InvestorFundraiser PDA (NEW - from refactoring):
- Seeds: [b"investor_fundraiser", investor_pubkey, fundraiser_pubkey]
- Stores: investor, fundraiser, investment_counter, bump
- Purpose: Track investment counter per investor-fundraiser pair

Investment PDA:
- Seeds: [b"investment", investor_pubkey, fundraiser_pubkey, investment_counter]
  (counter now comes from InvestorFundraiser PDA)
- Stores: investor, fundraiser, usdc_amount, reit_amount, status, bump
- Status enum: Pending, Released, Refunded, Wired, ShareIssued, ShareSold

2.2 EXISTING FLOW
-----------------
1. User deposits USDC → Investment PDA created
2. Admin releases funds → Off-chain CAD conversion
3. Admin mints REIT tokens → ShareIssued status
4. User receives REIT tokens in their wallet

================================================================================
3. PROPOSED DIVIDEND SYSTEM DESIGN
================================================================================

3.1 DIVIDEND COUNTER PDA STRUCTURE (NEW)
-----------------------------------------
DESIGN DECISION: 
Following the same pattern as InvestorFundraiser (from investment-counter-refactor-plan),
we create a dedicated counter PDA per investment for dividend tracking.

WHY NOT REUSE InvestorFundraiser?
- InvestorFundraiser tracks investment_counter (# of investments per investor-fundraiser)
- Dividends are issued per INVESTMENT (not per investor-fundraiser relationship)
- An investor can have multiple investments in same fundraiser (e.g., Investment #0, #1, #2)
- Each investment needs its own independent dividend sequence
- Mixing investment counter and dividend counter in same PDA violates separation of concerns

SOLANA MCP EXPERT RECOMMENDATION:
"Choose Option 2 with the refined PDA structure. It's the more robust and scalable 
solution for your dividend tracking requirements. Create a single InvestmentDividendCounter 
PDA for each investment."

Account Name: InvestmentDividendCounter
Purpose: Track dividend counter per investment
Seeds: [b"investment_dividend_counter", investment_pda]

Fields:
- dividend_counter: u64               // Counter for dividends issued for THIS investment
- bump: u8                            // PDA bump seed

Space: 8 + 1 = 9 bytes + 8 discriminator = 17 bytes

NOTE: Removed investment: Pubkey field per Solana MCP recommendation. 
The investment is already encoded in the PDA seeds, so storing it again 
is redundant and wastes space.

3.2 DIVIDEND PDA STRUCTURE
--------------------------
Based on spec requirements and Solana MCP recommendations:

Account Name: Dividend
Seeds: [b"dividend", investment_pda, dividend_counter]
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
       NOTE: Counter comes from InvestmentDividendCounter PDA

Fields:
- investor: Pubkey                    // Investor receiving dividend
- fundraiser: Pubkey                  // Associated fundraiser PDA
- investment: Pubkey                  // Specific investment this dividend relates to
- usdc_amount: u64                    // Dividend amount (in lamports, 1 USDC = 1,000,000)
- dividend_counter: u64               // Sequential counter for this investment's dividends
- timestamp: i64                      // Unix timestamp when dividend was issued
- bump: u8                            // PDA bump seed

Space Calculation: 32 + 32 + 32 + 8 + 8 + 8 + 1 = 121 bytes + 8 byte discriminator = 129 bytes

RATIONALE FOR STRUCTURE:
- InvestmentDividendCounter PDA per investment provides:
  * Correct per-investment dividend tracking
  * No ambiguity when investor has multiple investments
  * Sequential counters per investment (0, 1, 2... for each investment)
  * Deterministic PDA derivation
- Individual Dividend PDAs per payout provides:
  * Complete audit trail of all dividend payments
  * Ability to query payment history per investment
  * Better transparency for investors
  * Easier reconciliation and tax reporting
- Counter-based seeds allow unlimited dividend issuances over time

EXAMPLE SCENARIO:
Investor Alice has 2 investments in the SAME fundraiser:
- Investment A (counter 0) in Fundraiser X
- Investment B (counter 1) in Fundraiser X

Dividends issued:
1. First dividend for Investment A:
   - InvestmentDividendCounter PDA: [b"investment_dividend_counter", investment_A]
   - Counter value: 0
   - Dividend PDA: [b"dividend", investment_A, 0]

2. First dividend for Investment B:
   - InvestmentDividendCounter PDA: [b"investment_dividend_counter", investment_B]
   - Counter value: 0
   - Dividend PDA: [b"dividend", investment_B, 0]

3. Second dividend for Investment A:
   - InvestmentDividendCounter PDA: [b"investment_dividend_counter", investment_A]
   - Counter value: 1 (incremented from previous)
   - Dividend PDA: [b"dividend", investment_A, 1]

Result: Each investment has its own sequential dividend counter!
This mirrors the InvestorFundraiser pattern where each investor-fundraiser 
pair has its own investment counter.

3.3 ALTERNATIVE CONSIDERED: CUMULATIVE APPROACH
-----------------------------------------------
An alternative approach would store cumulative dividends:
- Single PDA per investment: [b"dividend_cumulative", investment_pda]
- Field: cumulative_dividends: u64

PROS: Lower PDA count, more gas efficient
CONS: No individual payout history, harder to audit

DECISION: Use individual PDAs for transparency and auditability requirements

3.4 WHY NOT USE investor_pubkey IN DIVIDEND SEEDS?
--------------------------------------------------
ORIGINAL SPEC PROPOSED: [b"dividends", investor_pubkey, investment_pda, counter]

PROBLEM: This creates dependency on investor_pubkey when it's already encoded
in the investment_pda. The investment PDA already contains the investor pubkey
in its seeds: [b"investment", investor_pubkey, fundraiser_pubkey, inv_counter]

BENEFITS OF SIMPLIFIED SEEDS: [b"dividend", investment_pda, dividend_counter]
- Simpler PDA derivation (fewer seeds)
- Investment PDA is unique per investor already
- Reduces seed length (stays within Solana limits)
- More efficient derivation
- Cleaner logical hierarchy: Investment → Dividends

================================================================================
4. INSTRUCTION DESIGN: issue_dividends
================================================================================

4.1 INSTRUCTION PARAMETERS
--------------------------
pub fn issue_dividends(
    ctx: Context<IssueDividends>,
    investment_pda: Pubkey,         // The investment to issue dividend for
    usdc_amount: u64,                // Dividend amount in smallest unit (1 USDC = 1_000_000)
) -> Result<()>

Note: investor_pubkey and fundraiser can be derived from investment_pda,
reducing instruction parameters

4.2 ACCOUNTS STRUCTURE
----------------------
#[derive(Accounts)]
#[instruction(investment_pda: Pubkey, usdc_amount: u64)]
pub struct IssueDividends<'info> {
    // Admin who signs and pays for transaction
    #[account(mut)]
    pub admin: Signer<'info>,
    
    // Admin's USDC token account (source of dividend funds)
    #[account(mut)]
    pub admin_usdc_ata: InterfaceAccount<'info, TokenAccount>,
    
    // Investment PDA that this dividend is for
    #[account(
        constraint = investment.status == InvestmentStatus::ShareIssued @ ErrorCode::InvalidInvestmentStatus
    )]
    pub investment: Account<'info, state::Investment>,
    
    // Investor receiving dividend (derived from investment)
    /// CHECK: Derived from investment.investor field
    pub investor: AccountInfo<'info>,
    
    // Investor's USDC token account (destination)
    #[account(
        mut,
        constraint = investor_usdc_ata.owner == investment.investor @ ErrorCode::InvalidTokenAccount
    )]
    pub investor_usdc_ata: InterfaceAccount<'info, TokenAccount>,
    
    // Fundraiser PDA for admin validation
    #[account(
        constraint = fundraiser.key() == investment.fundraiser @ ErrorCode::FundraiserMismatch,
        constraint = admin.key() == fundraiser.admin @ ErrorCode::UnauthorizedAdmin
    )]
    pub fundraiser: Account<'info, state::Fundraiser>,
    
    // Counter PDA to track dividend sequence (init_if_needed pattern)
    #[account(
        init_if_needed,
        payer = admin,
        space = 8 + InvestmentDividendCounter::INIT_SPACE,
        seeds = [b"investment_dividend_counter", investment.key().as_ref()],
        bump
    )]
    pub investment_dividend_counter: Account<'info, InvestmentDividendCounter>,
    
    // Dividend PDA to store this payout record
    #[account(
        init,
        payer = admin,
        space = 8 + Dividend::INIT_SPACE,
        seeds = [
            b"dividend",
            investment.key().as_ref(),
            &investment_dividend_counter.dividend_counter.to_le_bytes()
        ],
        bump
    )]
    pub dividend: Account<'info, state::Dividend>,
    
    // USDC mint for transfer validation
    #[account(
        constraint = usdc_mint.key() == fundraiser.usdc_mint @ ErrorCode::InvalidUsdcMint
    )]
    pub usdc_mint: InterfaceAccount<'info, Mint>,
    
    // System and token programs
    pub token_program: Interface<'info, TokenInterface>,
    pub system_program: Program<'info, System>,
}

CRITICAL CHANGES FROM ORIGINAL SPEC:
- Removed investor_pubkey parameter (derived from investment)
- Removed reit_id_hash parameter (fundraiser derived from investment)
- Changed dividend_counter account to investment_dividend_counter
- Seeds changed to: [b"dividend", investment_pda, counter] (not investor_pubkey)
- Counter PDA seeds: [b"investment_dividend_counter", investment_pda]

4.3 NEW HELPER STRUCTURE: InvestmentDividendCounter
---------------------------------------------------
File: anchor/programs/canadianreitinvest/src/state.rs

/// Tracks dividend issuance for a specific investment
/// Seeds: [b"investment_dividend_counter", investment_pda]
#[account]
#[derive(InitSpace)]
pub struct InvestmentDividendCounter {
    pub dividend_counter: u64,  // Increments with each dividend payout for THIS investment
    pub bump: u8,              // PDA bump seed
}

Purpose: Enables deterministic PDA derivation with sequential counter per investment
Pattern: Mirrors InvestorFundraiser structure for consistency
Space: 9 bytes + 8 discriminator = 17 bytes total

4.4 NEW STRUCTURE: Dividend
----------------------------
#[account]
#[derive(InitSpace)]
pub struct Dividend {
    pub investor: Pubkey,           // Investor who received this dividend
    pub fundraiser: Pubkey,         // Fundraiser this dividend relates to
    pub investment: Pubkey,         // Investment this dividend was issued for
    pub usdc_amount: u64,           // Dividend amount in USDC smallest unit
    pub dividend_counter: u64,      // Counter value for this dividend
    pub timestamp: i64,             // When dividend was issued
    pub bump: u8,                   // PDA bump seed
}

4.5 INSTRUCTION LOGIC
---------------------
1. Validate admin authority (via fundraiser constraint)
2. Validate investment exists and has ShareIssued status
3. Derive investor from investment PDA
4. Initialize or get InvestmentDividendCounter PDA for this investment
5. Get current dividend counter value for THIS investment
6. Perform USDC transfer (admin ATA → investor ATA)
   - Use token_interface::transfer_checked for security
   - Amount in smallest unit (1 USDC = 1,000,000)
   - Validate mint decimals
7. Initialize Dividend PDA with payout data
8. Increment InvestmentDividendCounter for future dividends
9. Emit DividendIssued event for off-chain tracking

Handler pseudocode:
```rust
pub fn handler(ctx: Context<IssueDividends>, usdc_amount: u64) -> Result<()> {
    // Validate investment is ready for dividends
    require!(
        ctx.accounts.investment.status == InvestmentStatus::ShareIssued,
        ErrorCode::InvalidInvestmentStatus
    );
    
    // Initialize counter if first dividend for this investment
    // (init_if_needed handles this, but we still check for initialization logic)
    let counter = &mut ctx.accounts.investment_dividend_counter;
    if counter.dividend_counter == 0 && counter.bump == 0 {
        // First time initialization
        counter.dividend_counter = 0;
        counter.bump = ctx.bumps.investment_dividend_counter;
    }
    
    // Transfer USDC from admin to investor
    let cpi_accounts = TransferChecked {
        from: ctx.accounts.admin_usdc_ata.to_account_info(),
        to: ctx.accounts.investor_usdc_ata.to_account_info(),
        authority: ctx.accounts.admin.to_account_info(),
        mint: ctx.accounts.usdc_mint.to_account_info(),
    };
    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_context = CpiContext::new(cpi_program, cpi_accounts);
    transfer_checked(cpi_context, usdc_amount, ctx.accounts.usdc_mint.decimals)?;
    
    // Initialize Dividend PDA
    let dividend = &mut ctx.accounts.dividend;
    dividend.investor = ctx.accounts.investment.investor;
    dividend.fundraiser = ctx.accounts.investment.fundraiser;
    dividend.investment = ctx.accounts.investment.key();
    dividend.usdc_amount = usdc_amount;
    dividend.dividend_counter = counter.dividend_counter;
    dividend.timestamp = Clock::get()?.unix_timestamp;
    dividend.bump = ctx.bumps.dividend;
    
    // Increment counter for next dividend
    counter.dividend_counter = counter.dividend_counter
        .checked_add(1)
        .ok_or(ErrorCode::DividendCounterOverflow)?;
    
    // Emit event
    emit!(DividendIssued {
        investor: dividend.investor,
        investment: dividend.investment,
        fundraiser: dividend.fundraiser,
        usdc_amount: dividend.usdc_amount,
        dividend_counter: dividend.dividend_counter,
        timestamp: dividend.timestamp,
    });
    
    Ok(())
}
```

KEY IMPLEMENTATION NOTES:
- Uses init_if_needed on counter PDA (similar to invest instruction pattern)
- Checks counter initialization state before first use
- Uses checked_add for counter increment (prevents overflow)
- Follows same pattern as invest instruction with InvestorFundraiser

4.6 SECURITY VALIDATIONS
------------------------
✓ Admin-only: Constraint validates admin.key() == fundraiser.admin
✓ No double-spend: Each counter value per investment creates unique PDA
✓ Investment validation: Ensures investment has ShareIssued status
✓ Investment-fundraiser link: Ensures investment belongs to correct fundraiser
✓ Amount validation: Should add check for reasonable amount (e.g., < 1M USDC)
✓ Token account validation: Ensures correct mint, owner, and account relationships
✓ Transfer authority: Admin must own admin_usdc_ata
✓ Per-investment counter: Each investment tracks its own dividend sequence

ADDITIONAL RECOMMENDED CHECKS:
- Verify admin has sufficient USDC balance before transfer
- Add maximum dividend amount constraint
- Emit detailed events for audit trail

4.7 USDC AMOUNT HANDLING
-------------------------
CRITICAL: USDC has 6 decimals on Solana

Input amount representation:
- 1 USDC = 1,000,000 (1e6) smallest units
- 0.1 USDC = 100,000
- 10 USDC = 10,000,000

Frontend must convert UI display to smallest unit before calling instruction
Backend instruction expects amount in smallest unit (lamport-equivalent for USDC)

Example:
Admin wants to distribute 5 USDC dividend:
- Frontend UI input: 5.00
- Conversion: 5 * 1_000_000 = 5_000_000
- Instruction call: issue_dividends(..., 5_000_000)

================================================================================
5. EVENT EMISSION
================================================================================

5.1 EVENT STRUCTURE
-------------------
#[event]
pub struct DividendIssued {
    pub investor: Pubkey,
    pub investment: Pubkey,
    pub fundraiser: Pubkey,
    pub usdc_amount: u64,
    pub dividend_counter: u64,
    pub timestamp: i64,
}

Purpose: Off-chain indexing, analytics, notifications

5.2 EMISSION POINT
------------------
Emit after successful USDC transfer and PDA initialization:

emit!(DividendIssued {
    investor: ctx.accounts.investment.investor,
    investment: ctx.accounts.investment.key(),
    fundraiser: ctx.accounts.investment.fundraiser,
    usdc_amount: usdc_amount,
    dividend_counter: ctx.accounts.investment_dividend_counter.dividend_counter,
    timestamp: Clock::get()?.unix_timestamp,
});

================================================================================
6. FRONTEND IMPLEMENTATION
================================================================================

6.1 ADMIN DASHBOARD - NEW PAGE
-------------------------------
Route: /admin/dividends (or similar)

Page Components:
1. Investor Selection Dropdown
2. Dividend Amount Input
3. Submit Button
4. Transaction Status Display

6.2 INVESTOR LIST FETCHING
---------------------------
Requirement: Fetch list of investors with email and wallet pubkey

Approach:
- Use React Query for data fetching
- Query backend API/database for investor records
- Filter for investors with ShareIssued investments (status = 4)
- Display format: "investor@email.com (8XLF...ieK)"

API Endpoint (to be created):
GET /api/admin/investors
Response: [
  {
    email: "investor@example.com",
    walletPubkey: "8XLFJExNrXT91Bz6ZdXfrBmicCCAY1U1UDSA7Vdi5ieK",
    investmentsPda: ["investmentPda1", "investmentPda2"],
    totalInvestment: 50000000000, // USDC smallest unit
    reitTokensOwned: 5000
  },
  ...
]

6.3 FORM STRUCTURE
------------------
```tsx
<Form>
  <Select
    label="Select Investor"
    options={investors}
    value={selectedInvestor}
    onChange={handleInvestorChange}
    renderOption={(inv) => `${inv.email} (${truncate(inv.walletPubkey)})`}
  />
  
  <NumberInput
    label="Dividend Amount (USDC)"
    value={dividendAmount}
    onChange={setDividendAmount}
    min={0}
    step={0.01}
    placeholder="Enter dividend amount"
  />
  
  <Select
    label="Related Investment"
    options={selectedInvestor?.investmentsPda}
    value={selectedInvestment}
    onChange={setSelectedInvestment}
    disabled={!selectedInvestor}
  />
  
  <Button
    onClick={handleSubmitDividend}
    disabled={!selectedInvestor || !dividendAmount || !selectedInvestment}
  >
    Issue Dividend
  </Button>
</Form>
```

6.4 TRANSACTION CONSTRUCTION
-----------------------------
Using generated Codama types:

```typescript
import { issueDividendsInstruction } from '@/generated/canadianreitinvest';

const handleSubmitDividend = async () => {
  // Convert USDC to smallest unit (6 decimals)
  const usdcSmallestUnit = dividendAmount * 1_000_000;
  
  // Get investment PDA (already selected from dropdown)
  const investmentPda = new PublicKey(selectedInvestment);
  
  // Fetch investment to get investor and fundraiser
  const investment = await program.account.investment.fetch(investmentPda);
  const investorPubkey = investment.investor;
  const fundraiserPda = investment.fundraiser;
  
  // Get or derive required accounts
  const adminPubkey = wallet.publicKey;
  const adminUsdcAta = getAssociatedTokenAddress(USDC_MINT, adminPubkey);
  const investorUsdcAta = getAssociatedTokenAddress(
    USDC_MINT, 
    investorPubkey
  );
  
  // Derive InvestmentDividendCounter PDA
  const [investmentDividendCounterPda] = PublicKey.findProgramAddressSync(
    [
      Buffer.from("investment_dividend_counter"),
      investmentPda.toBuffer()
    ],
    PROGRAM_ID
  );
  
  // Fetch or initialize counter to get current value
  let dividendCounter = 0;
  try {
    const counterAccount = await program.account.investmentDividendCounter.fetch(
      investmentDividendCounterPda
    );
    dividendCounter = counterAccount.dividendCounter.toNumber();
  } catch (e) {
    // Counter doesn't exist yet, will be initialized to 0
    dividendCounter = 0;
  }
  
  // Derive Dividend PDA with current counter value
  const [dividendPda] = PublicKey.findProgramAddressSync(
    [
      Buffer.from("dividend"),
      investmentPda.toBuffer(),
      Buffer.from(new Uint8Array(new BigUint64Array([BigInt(dividendCounter)]).buffer))
    ],
    PROGRAM_ID
  );
  
  // Build instruction
  const instruction = issueDividendsInstruction({
    admin: adminPubkey,
    adminUsdcAta,
    investment: investmentPda,
    investor: investorPubkey,
    investorUsdcAta,
    fundraiser: fundraiserPda,
    investmentDividendCounter: investmentDividendCounterPda,
    dividend: dividendPda,
    usdcMint: USDC_MINT,
    tokenProgram: TOKEN_PROGRAM_ID,
    systemProgram: SystemProgram.programId,
  }, {
    investmentPda: investmentPda,
    usdcAmount: usdcSmallestUnit,
  });
  
  // Send transaction
  const transaction = new Transaction().add(instruction);
  const signature = await sendTransaction(transaction, connection);
  await connection.confirmTransaction(signature);
  
  // Show success notification
  toast.success(`Dividend issued successfully! TX: ${signature}`);
};
```

CRITICAL CHANGES FROM ORIGINAL:
- Simplified parameters: Only investment_pda and usdc_amount needed
- Derive investor and fundraiser from investment (no need to pass separately)
- Use InvestmentDividendCounter PDA (per-investment, not global)
- Simpler PDA seeds: [b"dividend", investment_pda, counter]
- Fetch counter before deriving dividend PDA to get correct seed

6.5 UI/UX CONSIDERATIONS
------------------------
- Use Shadcn components for consistent design
- Display amounts in human-readable format (5.00 USDC, not 5000000)
- Show loading states during transaction
- Display transaction signature with Solana Explorer link
- Add confirmation modal before submission
- Validate admin has sufficient USDC balance before submitting
- Show previous dividend history for selected investor

================================================================================
7. BACKEND INTEGRATION NEEDS
================================================================================

7.1 DATABASE SCHEMA UPDATES
----------------------------
If using Supabase (as indicated in project structure):

Table: dividends_history
Columns:
- id: UUID (primary key)
- investor_email: TEXT
- investor_wallet: TEXT
- investment_pda: TEXT
- fundraiser_pda: TEXT
- usdc_amount: BIGINT (smallest unit)
- dividend_counter: INTEGER
- transaction_signature: TEXT
- issued_at: TIMESTAMP
- issued_by_admin: TEXT
- created_at: TIMESTAMP DEFAULT NOW()

Purpose: Off-chain record keeping, reporting, tax documents

7.2 API ENDPOINTS
-----------------
POST /api/admin/dividends/issue
- Validates admin authentication
- Constructs and sends transaction
- Records in database
- Returns transaction signature

GET /api/admin/dividends/history?investor=<pubkey>
- Fetches dividend history for investor
- Returns paginated results

GET /api/admin/investors
- Lists all investors with investment data
- Filters by investment status

7.3 WEBHOOK/LISTENER (Optional Enhancement)
--------------------------------------------
Listen for DividendsIssued events:
- Update database automatically
- Send email notifications to investors
- Trigger analytics updates

================================================================================
8. SECURITY CONSIDERATIONS
================================================================================

8.1 ATTACK VECTORS & MITIGATIONS
---------------------------------
✓ Unauthorized dividend issuance
  → Constraint: admin.key() == fundraiser.admin

✓ Double-spend of dividends
  → Unique PDA per counter value prevents re-initialization

✓ Dividend to wrong investor
  → Constraint validates investor matches investment.investor

✓ Incorrect investment association
  → Constraint validates investment.fundraiser == fundraiser

✓ Amount manipulation
  → Consider adding maximum dividend amount check
  → Consider checking admin ATA balance before transfer

✓ Front-running attacks
  → N/A - admin-only operation

✓ Reentrancy
  → Anchor framework provides protection
  → Transfer happens before PDA init (proper ordering)

8.2 RECOMMENDED ADDITIONAL CHECKS
----------------------------------
1. Add maximum dividend amount constraint (e.g., < 1,000,000 USDC)
2. Verify admin has sufficient USDC balance
3. Add time-based rate limiting (prevent spam)
4. Consider adding approval workflow (multi-sig for large amounts)

8.3 AUDIT CHECKLIST
-------------------
□ All account constraints properly defined
□ PDA seeds properly documented
□ Transfer uses transfer_checked (not transfer)
□ Decimal handling correct for USDC (6 decimals)
□ Event emission includes all relevant data
□ Error codes defined for all failure cases
□ Integration tests cover all scenarios
□ Admin-only actions properly gated

================================================================================
9. IMPLEMENTATION SEQUENCE
================================================================================

9.1 PHASE 1: ONCHAIN PROGRAM (Anchor)
---------------------------------------
Step 1.1: Define state structures
  □ Add InvestmentDividendCounter struct to state.rs
  □ Add Dividend struct to state.rs
  □ Update InitSpace derives
  □ Add comments documenting PDA seeds

Step 1.2: Create instruction file
  □ Create anchor/programs/canadianreitinvest/src/instructions/issue_dividends.rs
  □ Define IssueDividends accounts struct
  □ Implement handler function
  □ Add error codes to errors.rs (DividendCounterOverflow, InvalidInvestmentStatus, etc.)

Step 1.3: Wire up in lib.rs
  □ Import issue_dividends module
  □ Add pub fn issue_dividends entry point
  □ Export new state structures

Step 1.4: Add event definition
  □ Define DividendIssued event in lib.rs or events.rs
  □ Emit in handler after successful transfer

9.2 PHASE 2: CODAMA TYPE GENERATION
-------------------------------------
Step 2.1: Generate TypeScript types
  □ Build program: cd anchor && anchor build
  □ Generate types: npm run codama:js (from root, NOT anchor subfolder)
  □ Verify generated files in src/generated/

Step 2.2: Update frontend imports
  □ Import issueDividendsInstruction from generated types
  □ Import InvestmentDividendCounter and Dividend type definitions
  □ Add to barrel exports if needed

9.3 PHASE 3: BACKEND API
--------------------------
Step 3.1: Database migrations
  □ Create dividends_history table (if using Supabase)
  □ Add indexes for querying (investor_wallet, investment_pda, issued_at)
  □ Test migrations on local Supabase instance

Step 3.2: API endpoints
  □ Implement POST /api/admin/dividends/issue
  □ Implement GET /api/admin/investors (filter by ShareIssued status)
  □ Implement GET /api/admin/dividends/history?investor=<pubkey>
  □ Add authentication middleware (admin-only)

Step 3.3: Integration utilities
  □ Create PDA derivation helpers in shared utilities
  □ Create USDC amount conversion helper (UI ↔ smallest unit)
  □ Add transaction construction utilities

9.4 PHASE 4: FRONTEND UI
--------------------------
Step 4.1: Create admin dividend page
  □ Create src/features/admin/dividends/ directory
  □ Implement dividend-page.tsx component
  □ Add route to app-routes.tsx
  □ Add navigation link in admin dashboard

Step 4.2: Build form components
  □ Investor selection dropdown with search
  □ Investment selection dropdown (filtered by investor)
  □ Amount input with validation (min 0.01 USDC)
  □ Submit button with loading state
  □ Confirmation modal before submission

Step 4.3: Implement transaction logic
  □ Create useIssueDividend hook
  □ Implement account derivation functions
  □ Build transaction with proper accounts
  □ Handle signature confirmation
  □ Error handling and user feedback (toast notifications)

Step 4.4: Add history view
  □ Display past dividends for selected investor/investment
  □ Format amounts correctly (convert from smallest unit)
  □ Link to Solana Explorer for each transaction
  □ Export to CSV functionality for tax reporting

================================================================================
10. RISK ASSESSMENT
================================================================================

10.1 TECHNICAL RISKS
--------------------
RISK: PDA collision if counter not properly incremented
LIKELIHOOD: Low
MITIGATION: Atomic counter increment via checked_add, init_if_needed pattern

RISK: USDC amount calculation errors (decimal handling)
LIKELIHOOD: Medium
MITIGATION: Frontend validation, conversion utilities, display formatting

RISK: Admin wallet compromise leading to unauthorized dividends
LIKELIHOOD: Low
MITIGATION: Hardware wallet, multi-sig (future), amount limits, rate limiting

RISK: Frontend/backend desync on account derivation
LIKELIHOOD: Medium
MITIGATION: Shared utility functions, consistent encoding (u64 little-endian)

10.2 OPERATIONAL RISKS
----------------------
RISK: Distributing dividends to wrong investors
LIKELIHOOD: Low
MITIGATION: Confirmation modal, preview before submit, audit logs

RISK: Incorrect dividend amounts
LIKELIHOOD: Medium
MITIGATION: Amount validation, preview display, approval workflow

RISK: Running out of admin USDC during distributions
LIKELIHOOD: Low
MITIGATION: Pre-flight balance check, error handling, batch monitoring

10.3 COMPLIANCE RISKS
---------------------
RISK: Tax reporting for dividend distributions
LIKELIHOOD: High
MITIGATION: Comprehensive logging, CSV export, on-chain audit trail

RISK: Regulatory requirements for dividend disclosures
LIKELIHOOD: Medium
MITIGATION: Legal consultation, maintain detailed records

================================================================================
11. FUTURE ENHANCEMENTS
================================================================================

11.1 BATCH DIVIDEND DISTRIBUTION
---------------------------------
Allow admin to issue dividends to multiple investors in single transaction
- Reduces transaction costs
- Faster distribution
- Requires careful PDA management
- Consider using Anchor's remaining_accounts pattern

11.2 PROPORTIONAL DIVIDEND CALCULATION
---------------------------------------
Auto-calculate dividend per investor based on REIT token holdings
- Query all investors' token balances
- Calculate proportional distribution
- Generate transactions programmatically
- Useful for quarterly distributions

11.3 SCHEDULED DIVIDENDS
-------------------------
Set up recurring dividend distributions
- Quarterly/monthly schedules
- Automated execution via Clockwork or similar
- Email notifications to investors
- Integration with calendar systems

11.4 DIVIDEND REINVESTMENT
---------------------------
Allow investors to auto-reinvest dividends into more REIT tokens
- Optional flag on investment or investor profile
- Direct purchase of additional shares
- Compound returns over time
- Tax implications to consider

11.5 MULTI-SIGNATURE APPROVAL
------------------------------
Require multiple admin approvals for large dividend amounts
- Squads Protocol integration
- Threshold-based triggers (e.g., > $10k requires 2-of-3 approval)
- Enhanced security for mainnet
- Audit trail of approvers

================================================================================
13. SUCCESS CRITERIA
================================================================================

Project will be considered successful when:

✓ Admin can issue USDC dividends to specific investments via UI
✓ Dividends are recorded on-chain with complete audit trail
✓ USDC transfers execute correctly (6 decimal handling)
✓ No duplicate dividends can be issued for same counter value
✓ Only authorized admins can issue dividends
✓ Events are emitted for off-chain tracking and notifications
✓ Frontend UI is intuitive and provides clear feedback
✓ Database records match on-chain state
✓ Transaction confirmations visible to admin with explorer links

Performance Benchmarks:
- Transaction confirmation: < 30 seconds (typical Solana time)
- UI responsiveness: < 200ms for user interactions
- Database sync delay: < 10 seconds after transaction confirmation

================================================================================
14. DEPENDENCIES & PREREQUISITES
================================================================================

14.1 ONCHAIN DEPENDENCIES
--------------------------
□ Anchor Framework 0.30.x+ (compatible with project version)
□ Solana Program Library (SPL Token)
□ USDC mint address (mainnet/devnet/localnet)
□ Existing program structure (fundraiser, investment PDAs)

14.2 FRONTEND DEPENDENCIES
---------------------------
□ @solana/web3.js
□ @solana/wallet-adapter
□ @solana/spl-token
□ React Query (for data fetching)
□ Codama (for type generation)
□ Shadcn UI components

14.3 BACKEND DEPENDENCIES
--------------------------
□ Supabase client (if using)

14.4 INFRASTRUCTURE
-------------------
□ Solana RPC endpoint (Chainstack/QuickNode/Helius)
□ Database for off-chain records (Supabase recommended)
□ Admin wallet with USDC for distributions
□ Secure key management for admin wallet

================================================================================
15. SOLANA MCP EXPERT RECOMMENDATIONS INCORPORATED
================================================================================

From consultation with Solana MCP server:

✓ Create separate InvestmentDividendCounter PDA per investment
  → "Choose Option 2 with the refined PDA structure. It's the more robust 
     and scalable solution."
  → Do NOT reuse InvestorFundraiser for dividend tracking

✓ Minimal PDA structure for counter
  → Removed redundant investment: Pubkey field
  → Investment already encoded in PDA seeds
  → Saves space: 17 bytes vs 49 bytes

✓ Use token_interface::transfer_checked (not transfer)
  → Ensures mint, decimals, and amount validation
  → Required for security

✓ PDA seeds: [b"dividend", investment_pda, counter]
  → Deterministic and collision-free
  → Each investment has independent dividend sequence

✓ Emit events for off-chain tracking
  → Include all relevant data points (investor, investment, fundraiser, amount)
  → Timestamp for ordering

✓ Authority checks via Anchor constraints
  → admin.key() == fundraiser.admin
  → Prevents unauthorized operations

✓ init_if_needed pattern for counter initialization
  → Follows same pattern as invest instruction
  → Reduces code complexity

✓ Use checked_add for counter increment
  → Prevents overflow attacks
  → Safe arithmetic operations

================================================================================
16. ALIGNMENT WITH INVESTMENT COUNTER REFACTORING
================================================================================

This dividend implementation follows the same architectural patterns as the
investment counter refactoring (see investment-counter-refactor-plan.txt):

PATTERN CONSISTENCY:
- InvestorFundraiser PDA: Tracks investment_counter per investor-fundraiser
- InvestmentDividendCounter PDA: Tracks dividend_counter per investment
- Both use init_if_needed pattern for counter initialization
- Both use checked_add for safe counter increment
- Both use u64 counters with little-endian encoding

WHY THIS PATTERN WORKS:
1. Clear separation of concerns
2. Each entity has its own counter scope
3. No ambiguity when multiple relationships exist
4. Deterministic PDA derivation
5. Scales indefinitely (u64 max = 18 quintillion)

IMPLEMENTATION LEARNINGS APPLIED:
□ Pass counter as instruction parameter (for proper seed derivation)
□ Use Buffer.writeBigUInt64LE in TypeScript for u64 encoding
□ Match Rust's to_le_bytes() encoding exactly
□ Initialize counter to 0 on first use
□ Increment after successful operation

================================================================================
17. NOTES FOR IMPLEMENTERS
================================================================================

CRITICAL REMINDERS:
1. Do NOT install codama deps in anchor/ folder
   - Use root-level codama: npm run codama:js from project root
   - Never run npm install in anchor/ directory

2. Counter encoding MUST match between TypeScript and Rust
   - TypeScript: Buffer.writeBigUInt64LE(counter, 0)
   - Rust: counter.to_le_bytes()
   - Mismatch causes ConstraintSeeds errors

3. init_if_needed requires payer parameter
   - Admin pays for PDA initialization
   - Ensure admin has sufficient SOL balance

4. USDC decimals = 6 (not 9 like SOL)
   - 1 USDC = 1,000,000 smallest units
   - Always use transfer_checked with correct decimals

5. Test on localnet before devnet/mainnet
   - See guide/USDC_LOCALNET_GUIDE.md for setup
   - Create test investments with ShareIssued status
   - Verify counter increments correctly

================================================================================
18. REVIEW & APPROVAL
================================================================================

This plan should be reviewed by:
□ Lead Developer (technical implementation feasibility)
□ Product Owner (feature requirements alignment)
□ Security Auditor (security considerations)
□ Admin User (UI/UX usability)

Approval required before proceeding to implementation.

Approval Signatures:
_______________________  Date: __________
Lead Developer

_______________________  Date: __________
Product Owner

================================================================================
END OF IMPLEMENTATION PLAN
================================================================================

Document Version: 1.2 (UPDATED - Aligned with Investment Counter Refactoring)
Last Updated: October 28, 2025
Next Review: After Phase 1 completion (onchain program implementation)

Related Documents:
- investment-counter-refactor-plan.txt (architectural patterns)
- .github/copilot-instructions.md (project guidelines)
- guide/USDC_LOCALNET_GUIDE.md (testing setup)

================================================================================
APPENDIX A: KEY CHANGES FROM VERSION 1.1
================================================================================

VERSION 1.1 → 1.2 UPDATES:

1. CLARIFIED WHY NOT TO REUSE InvestorFundraiser
   - Added detailed explanation at document start
   - Emphasized per-investment vs per-investor-fundraiser distinction
   - Included Solana MCP expert recommendation

2. UPDATED STATE STRUCTURE SECTION
   - Reflected current codebase after investment counter refactoring
   - Documented InvestorFundraiser PDA addition
   - Noted investment_counter removal from Investor PDA

3. OPTIMIZED InvestmentDividendCounter SIZE
   - Removed redundant investment: Pubkey field
   - Reduced from 49 bytes to 17 bytes total
   - Investment already encoded in PDA seeds

4. ENHANCED EXAMPLE SCENARIO
   - Added case with multiple investments in SAME fundraiser
   - Clarified counter independence per investment
   - Showed parallel with InvestorFundraiser pattern

5. IMPROVED HANDLER LOGIC
   - Added initialization state checking
   - Documented init_if_needed behavior
   - Added implementation notes

6. REMOVED TESTING & DEPLOYMENT SECTIONS
   - Focused on implementation planning only
   - Matches investment-counter-refactor-plan format
   - Reduces document complexity

7. EXPANDED IMPLEMENTATION SEQUENCE
   - More detailed steps per phase
   - Added specific file locations
   - Included validation checkpoints

8. ADDED ALIGNMENT SECTION
   - Cross-referenced investment counter refactoring
   - Documented pattern consistency
   - Explained architectural decisions

9. ENHANCED NOTES FOR IMPLEMENTERS
   - Critical reminders about codama usage
   - Encoding best practices
   - Common pitfalls to avoid

RATIONALE FOR CHANGES:
- Align with actual implemented investment counter refactoring
- Incorporate Solana MCP expert recommendations
- Optimize for developer clarity and implementation success
- Reduce redundancy and document size

================================================================================

================================================================================
14. SUCCESS CRITERIA
================================================================================

Project will be considered successful when:

✓ Admin can issue USDC dividends to investors via UI
✓ Dividends are recorded on-chain with proper audit trail
✓ USDC transfers execute correctly (6 decimal handling)
✓ No duplicate dividends can be issued
✓ Only authorized admins can issue dividends
✓ Events are emitted for off-chain tracking
✓ Frontend UI is intuitive and error-free
✓ Database records match on-chain state
✓ Transaction confirmations visible to admin

Performance Benchmarks:
- Transaction confirmation: < 5 seconds
- UI responsiveness: < 200ms for interactions
- Database sync delay: < 10 seconds after transaction

================================================================================
16. SOLANA MCP EXPERT RECOMMENDATIONS INCORPORATED
================================================================================

From consultation with Solana MCP server:

✓ Use token_interface::transfer_checked (not transfer)
  → Ensures mint, decimals, and amount validation

✓ PDA seeds include investor, investment, and counter
  → Allows multiple dividends over time
  → Deterministic and collision-free

✓ Emit events for off-chain tracking
  → Include all relevant data points
  → Timestamp for ordering

✓ Authority checks via Anchor constraints
  → admin.key() == fundraiser.admin
  → Prevents unauthorized operations

✓ Separate PDAs per payout vs cumulative
  → Decision: Individual PDAs for audit trail
  → Trade-off accepted: More accounts vs better transparency

✓ Consider rate limiting and amount caps
  → Added to security recommendations
  → Prevents accidental large distributions

✓ Test decimal handling extensively
  → USDC has 6 decimals, not 9 like SOL
  → Critical for correct transfers


================================================================================
END OF IMPLEMENTATION PLAN
================================================================================

Document Version: 1.1 (UPDATED - Critical Architecture Fix)
Last Updated: October 27, 2025
Next Review: After Phase 1 completion

================================================================================
APPENDIX A: CRITICAL CHANGES FROM ORIGINAL SPEC (v1.0 → v1.1)
================================================================================

PROBLEM IDENTIFIED:
The original spec used a global DividendCounter PDA with seeds:
  [b"dividend_counter", investor_pubkey, investment_pda]

This had the same fundamental flaw as the investment_counter issue:
- If an investor has multiple investments, we cannot determine which counter 
  to use for which investment
- Counter would be global across all investments for that investor-investment pair
- Seeds were unnecessarily complex with redundant investor_pubkey

SOLUTION IMPLEMENTED:
Changed to per-investment counter with simpler seeds:
  InvestmentDividendCounter PDA: [b"investment_dividend_counter", investment_pda]
  Dividend PDA: [b"dividend", investment_pda, dividend_counter]

BENEFITS:
✓ Each investment has its own dividend counter (0, 1, 2...)
✓ No ambiguity when investor has multiple investments
✓ Simpler PDA derivation (investment_pda already encodes investor)
✓ Logical hierarchy: Investment → Dividends
✓ Matches the pattern used in InvestorFundraiser refactoring

KEY STRUCTURAL CHANGES:
1. Added InvestmentDividendCounter struct and PDA
2. Changed Dividend PDA seeds (removed investor_pubkey)
3. Simplified instruction parameters (only investment_pda + amount)
4. Updated frontend derivation logic
5. Updated event emission

RELATED REFACTORING:
This change parallels the investment_counter refactoring documented in:
  .github/spec/v1/tasks/investment-counter-refactor-plan.txt

Both refactorings solve the same architectural issue: using per-relationship
counters instead of global counters.

================================================================================
APPENDIX B: SOLANA MCP EXPERT VALIDATION
================================================================================

From Solana MCP consultation:

"Yes, a similar pattern for dividend tracking is recommended. Create a 
DividendCounter PDA:
  - DividendCounter PDA: [b"dividend_counter", investor_pubkey, investment_pda]
  - Fields: dividend_counter: u64

This approach provides the same benefits as the InvestorFundraiser PDA:
  - Per-Investment Tracking: Each investment has its own dividend counter
  - Scalability: You can track an unlimited number of dividends per investment
  - Deterministic Addresses: You can easily derive the address of any dividend 
    for a given investment"

NOTE: We further simplified from the MCP recommendation by removing investor_pubkey
from seeds since investment_pda already uniquely identifies the investor-investment
relationship.

For questions or clarifications, consult:
- Solana MCP server (for Solana/Anchor technical questions)
- .github/copilot-instructions.md (for project-specific context)
- anchor/programs/canadianreitinvest/src/ (for existing code patterns)
