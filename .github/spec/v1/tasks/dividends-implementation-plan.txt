================================================================================
DIVIDEND DISTRIBUTION SYSTEM - IMPLEMENTATION PLAN
Canadian REIT Investment Platform
================================================================================

VERSION: 1.1 (UPDATED - Fixed Dividend Counter Architecture)
DATE: October 27, 2025
STATUS: Planning Phase - Not Yet Implemented

CRITICAL UPDATE:
This plan has been updated to fix a critical design flaw in the dividend 
counter mechanism. The original design used a single global counter which 
would not work correctly for multiple dividends per investment. The updated 
design uses an InvestmentDividendCounter PDA to track dividends per investment.

================================================================================
1. OVERVIEW
================================================================================

This document outlines the implementation plan for a dividend distribution
system that allows administrators to issue USDC dividend payments to investors
who hold tokenized REIT shares. The system tracks dividend payouts on-chain
via Solana PDAs and transfers USDC from admin wallets to investor wallets.

GOALS:
- Enable transparent, auditable dividend distributions
- Track dividend history per investor and investment
- Ensure secure, admin-only dividend issuance
- Prevent duplicate dividend payments
- Maintain proper accounting of cumulative dividends

================================================================================
2. CURRENT SYSTEM ARCHITECTURE
================================================================================

2.1 EXISTING STATE STRUCTURES
------------------------------
From anchor/programs/canadianreitinvest/src/state.rs:

Fundraiser PDA:
- Seeds: [b"fundraiser", reit_id_hash]
- Stores: admin, usdc_mint, reit_mint, escrow_vault, total_raised, etc.

Investor PDA:
- Seeds: [b"investor", investor_pubkey]
- Stores: investor_pubkey, investment_counter, bump

Investment PDA:
- Seeds: [b"investment", investor_pubkey, fundraiser_pubkey, investment_counter]
- Stores: investor, fundraiser, usdc_amount, reit_amount, status, bump
- Status enum: Pending, Released, Refunded, Wired, ShareIssued, ShareSold

2.2 EXISTING FLOW
-----------------
1. User deposits USDC → Investment PDA created
2. Admin releases funds → Off-chain CAD conversion
3. Admin mints REIT tokens → ShareIssued status
4. User receives REIT tokens in their wallet

================================================================================
3. PROPOSED DIVIDEND SYSTEM DESIGN
================================================================================

3.1 DIVIDEND COUNTER PDA STRUCTURE (NEW - CRITICAL FIX)
-------------------------------------------------------
PROBLEM IDENTIFIED: 
Similar to the investment_counter issue, we cannot use a global dividend counter.
Each Investment needs its own dividend counter to track multiple dividend 
distributions over time.

Account Name: InvestmentDividendCounter
Purpose: Track dividend counter per investment
Seeds: [b"investment_dividend_counter", investment_pda]

Fields:
- investment: Pubkey                  // The investment this counter tracks
- dividend_counter: u64               // Counter for dividends issued for THIS investment
- bump: u8                            // PDA bump seed

Space: 32 + 8 + 1 = 41 bytes + 8 discriminator = 49 bytes

3.2 DIVIDEND PDA STRUCTURE
--------------------------
Based on spec requirements and Solana MCP recommendations:

Account Name: Dividend
Seeds: [b"dividend", investment_pda, dividend_counter]
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
       NOTE: Counter comes from InvestmentDividendCounter PDA

Fields:
- investor: Pubkey                    // Investor receiving dividend
- fundraiser: Pubkey                  // Associated fundraiser PDA
- investment: Pubkey                  // Specific investment this dividend relates to
- usdc_amount: u64                    // Dividend amount (in lamports, 1 USDC = 1,000,000)
- dividend_counter: u64               // Sequential counter for this investment's dividends
- timestamp: i64                      // Unix timestamp when dividend was issued
- bump: u8                            // PDA bump seed

Space Calculation: 32 + 32 + 32 + 8 + 8 + 8 + 1 = 121 bytes + 8 byte discriminator = 129 bytes

RATIONALE FOR STRUCTURE:
- InvestmentDividendCounter PDA per investment provides:
  * Correct per-investment dividend tracking
  * No ambiguity when investor has multiple investments
  * Sequential counters per investment (0, 1, 2... for each investment)
  * Deterministic PDA derivation
- Individual Dividend PDAs per payout provides:
  * Complete audit trail of all dividend payments
  * Ability to query payment history per investment
  * Better transparency for investors
  * Easier reconciliation and tax reporting
- Counter-based seeds allow unlimited dividend issuances over time

EXAMPLE SCENARIO:
Investor Alice has 2 investments:
- Investment A in Fundraiser X
- Investment B in Fundraiser Y

Dividends issued:
1. Dividend for Investment A → Counter 0, Seeds: [b"dividend", investment_A, 0]
2. Dividend for Investment B → Counter 0, Seeds: [b"dividend", investment_B, 0]
3. Second dividend for Investment A → Counter 1, Seeds: [b"dividend", investment_A, 1]

Result: Each investment has its own sequential dividend counter!

3.3 ALTERNATIVE CONSIDERED: CUMULATIVE APPROACH
-----------------------------------------------
An alternative approach would store cumulative dividends:
- Single PDA per investment: [b"dividend_cumulative", investment_pda]
- Field: cumulative_dividends: u64

PROS: Lower PDA count, more gas efficient
CONS: No individual payout history, harder to audit

DECISION: Use individual PDAs for transparency and auditability requirements

3.4 WHY NOT USE investor_pubkey IN DIVIDEND SEEDS?
--------------------------------------------------
ORIGINAL SPEC PROPOSED: [b"dividends", investor_pubkey, investment_pda, counter]

PROBLEM: This creates dependency on investor_pubkey when it's already encoded
in the investment_pda. The investment PDA already contains the investor pubkey
in its seeds: [b"investment", investor_pubkey, fundraiser_pubkey, inv_counter]

BENEFITS OF SIMPLIFIED SEEDS: [b"dividend", investment_pda, dividend_counter]
- Simpler PDA derivation (fewer seeds)
- Investment PDA is unique per investor already
- Reduces seed length (stays within Solana limits)
- More efficient derivation
- Cleaner logical hierarchy: Investment → Dividends

================================================================================
4. INSTRUCTION DESIGN: issue_dividends
================================================================================

4.1 INSTRUCTION PARAMETERS
--------------------------
pub fn issue_dividends(
    ctx: Context<IssueDividends>,
    investment_pda: Pubkey,         // The investment to issue dividend for
    usdc_amount: u64,                // Dividend amount in smallest unit (1 USDC = 1_000_000)
) -> Result<()>

Note: investor_pubkey and fundraiser can be derived from investment_pda,
reducing instruction parameters

4.2 ACCOUNTS STRUCTURE
----------------------
#[derive(Accounts)]
#[instruction(investment_pda: Pubkey, usdc_amount: u64)]
pub struct IssueDividends<'info> {
    // Admin who signs and pays for transaction
    #[account(mut)]
    pub admin: Signer<'info>,
    
    // Admin's USDC token account (source of dividend funds)
    #[account(mut)]
    pub admin_usdc_ata: InterfaceAccount<'info, TokenAccount>,
    
    // Investment PDA that this dividend is for
    #[account(
        constraint = investment.status == InvestmentStatus::ShareIssued @ ErrorCode::InvalidInvestmentStatus
    )]
    pub investment: Account<'info, state::Investment>,
    
    // Investor receiving dividend (derived from investment)
    /// CHECK: Derived from investment.investor field
    pub investor: AccountInfo<'info>,
    
    // Investor's USDC token account (destination)
    #[account(
        mut,
        constraint = investor_usdc_ata.owner == investment.investor @ ErrorCode::InvalidTokenAccount
    )]
    pub investor_usdc_ata: InterfaceAccount<'info, TokenAccount>,
    
    // Fundraiser PDA for admin validation
    #[account(
        constraint = fundraiser.key() == investment.fundraiser @ ErrorCode::FundraiserMismatch,
        constraint = admin.key() == fundraiser.admin @ ErrorCode::UnauthorizedAdmin
    )]
    pub fundraiser: Account<'info, state::Fundraiser>,
    
    // Counter PDA to track dividend sequence (NEW)
    #[account(
        init_if_needed,
        payer = admin,
        space = 8 + 41, // discriminator + InvestmentDividendCounter size
        seeds = [b"investment_dividend_counter", investment.key().as_ref()],
        bump
    )]
    pub investment_dividend_counter: Account<'info, InvestmentDividendCounter>,
    
    // Dividend PDA to store this payout record
    #[account(
        init,
        payer = admin,
        space = 8 + 129, // discriminator + Dividend struct size
        seeds = [
            b"dividend",
            investment.key().as_ref(),
            &investment_dividend_counter.dividend_counter.to_le_bytes()
        ],
        bump
    )]
    pub dividend: Account<'info, state::Dividend>,
    
    // USDC mint for transfer validation
    #[account(
        constraint = usdc_mint.key() == fundraiser.usdc_mint @ ErrorCode::InvalidUsdcMint
    )]
    pub usdc_mint: InterfaceAccount<'info, Mint>,
    
    // System and token programs
    pub token_program: Interface<'info, TokenInterface>,
    pub system_program: Program<'info, System>,
}

CRITICAL CHANGES FROM ORIGINAL SPEC:
- Removed investor_pubkey parameter (derived from investment)
- Removed reit_id_hash parameter (fundraiser derived from investment)
- Changed dividend_counter account to investment_dividend_counter
- Seeds changed to: [b"dividend", investment_pda, counter] (not investor_pubkey)
- Counter PDA seeds: [b"investment_dividend_counter", investment_pda]

4.3 NEW HELPER STRUCTURE: InvestmentDividendCounter
---------------------------------------------------
#[account]
#[derive(InitSpace)]
pub struct InvestmentDividendCounter {
    pub investment: Pubkey,     // The investment this counter tracks
    pub dividend_counter: u64,  // Increments with each dividend payout for THIS investment
    pub bump: u8,              // PDA bump seed
}

Purpose: Enables deterministic PDA derivation with sequential counter per investment

4.4 NEW STRUCTURE: Dividend
----------------------------
#[account]
#[derive(InitSpace)]
pub struct Dividend {
    pub investor: Pubkey,           // Investor who received this dividend
    pub fundraiser: Pubkey,         // Fundraiser this dividend relates to
    pub investment: Pubkey,         // Investment this dividend was issued for
    pub usdc_amount: u64,           // Dividend amount in USDC smallest unit
    pub dividend_counter: u64,      // Counter value for this dividend
    pub timestamp: i64,             // When dividend was issued
    pub bump: u8,                   // PDA bump seed
}

4.5 INSTRUCTION LOGIC
---------------------
1. Validate admin authority (via fundraiser constraint)
2. Validate investment exists and has ShareIssued status
3. Derive investor from investment PDA
4. Initialize or get InvestmentDividendCounter PDA for this investment
5. Get current dividend counter value for THIS investment
6. Perform USDC transfer (admin ATA → investor ATA)
   - Use token_interface::transfer_checked for security
   - Amount in smallest unit (1 USDC = 1,000,000)
   - Validate mint decimals
7. Initialize Dividend PDA with payout data
8. Increment InvestmentDividendCounter for future dividends
9. Emit DividendIssued event for off-chain tracking

Handler pseudocode:
```rust
pub fn handler(ctx: Context<IssueDividends>, usdc_amount: u64) -> Result<()> {
    // Validate investment is ready for dividends
    require!(
        ctx.accounts.investment.status == InvestmentStatus::ShareIssued,
        ErrorCode::InvalidInvestmentStatus
    );
    
    // Initialize counter if first dividend for this investment
    let counter = &mut ctx.accounts.investment_dividend_counter;
    if counter.investment == Pubkey::default() {
        counter.investment = ctx.accounts.investment.key();
        counter.dividend_counter = 0;
        counter.bump = ctx.bumps.investment_dividend_counter;
    }
    
    // Transfer USDC from admin to investor
    let cpi_accounts = TransferChecked {
        from: ctx.accounts.admin_usdc_ata.to_account_info(),
        to: ctx.accounts.investor_usdc_ata.to_account_info(),
        authority: ctx.accounts.admin.to_account_info(),
        mint: ctx.accounts.usdc_mint.to_account_info(),
    };
    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_context = CpiContext::new(cpi_program, cpi_accounts);
    transfer_checked(cpi_context, usdc_amount, ctx.accounts.usdc_mint.decimals)?;
    
    // Initialize Dividend PDA
    let dividend = &mut ctx.accounts.dividend;
    dividend.investor = ctx.accounts.investment.investor;
    dividend.fundraiser = ctx.accounts.investment.fundraiser;
    dividend.investment = ctx.accounts.investment.key();
    dividend.usdc_amount = usdc_amount;
    dividend.dividend_counter = counter.dividend_counter;
    dividend.timestamp = Clock::get()?.unix_timestamp;
    dividend.bump = ctx.bumps.dividend;
    
    // Increment counter for next dividend
    counter.dividend_counter = counter.dividend_counter
        .checked_add(1)
        .ok_or(ErrorCode::DividendCounterOverflow)?;
    
    // Emit event
    emit!(DividendIssued {
        investor: dividend.investor,
        investment: dividend.investment,
        fundraiser: dividend.fundraiser,
        usdc_amount: dividend.usdc_amount,
        dividend_counter: dividend.dividend_counter,
        timestamp: dividend.timestamp,
    });
    
    Ok(())
}
```

4.6 SECURITY VALIDATIONS
------------------------
✓ Admin-only: Constraint validates admin.key() == fundraiser.admin
✓ No double-spend: Each counter value per investment creates unique PDA
✓ Investment validation: Ensures investment has ShareIssued status
✓ Investment-fundraiser link: Ensures investment belongs to correct fundraiser
✓ Amount validation: Should add check for reasonable amount (e.g., < 1M USDC)
✓ Token account validation: Ensures correct mint, owner, and account relationships
✓ Transfer authority: Admin must own admin_usdc_ata
✓ Per-investment counter: Each investment tracks its own dividend sequence

ADDITIONAL RECOMMENDED CHECKS:
- Verify admin has sufficient USDC balance before transfer
- Add maximum dividend amount constraint
- Consider rate limiting (e.g., max 1 dividend per investment per day)
- Emit detailed events for audit trail

4.7 USDC AMOUNT HANDLING
-------------------------
CRITICAL: USDC has 6 decimals on Solana

Input amount representation:
- 1 USDC = 1,000,000 (1e6) smallest units
- 0.1 USDC = 100,000
- 10 USDC = 10,000,000

Frontend must convert UI display to smallest unit before calling instruction
Backend instruction expects amount in smallest unit (lamport-equivalent for USDC)

Example:
Admin wants to distribute 5 USDC dividend:
- Frontend UI input: 5.00
- Conversion: 5 * 1_000_000 = 5_000_000
- Instruction call: issue_dividends(..., 5_000_000)

================================================================================
5. EVENT EMISSION
================================================================================

5.1 EVENT STRUCTURE
-------------------
#[event]
pub struct DividendIssued {
    pub investor: Pubkey,
    pub investment: Pubkey,
    pub fundraiser: Pubkey,
    pub usdc_amount: u64,
    pub dividend_counter: u64,
    pub timestamp: i64,
}

Purpose: Off-chain indexing, analytics, notifications

5.2 EMISSION POINT
------------------
Emit after successful USDC transfer and PDA initialization:

emit!(DividendIssued {
    investor: ctx.accounts.investment.investor,
    investment: ctx.accounts.investment.key(),
    fundraiser: ctx.accounts.investment.fundraiser,
    usdc_amount: usdc_amount,
    dividend_counter: ctx.accounts.investment_dividend_counter.dividend_counter,
    timestamp: Clock::get()?.unix_timestamp,
});

================================================================================
6. FRONTEND IMPLEMENTATION
================================================================================

6.1 ADMIN DASHBOARD - NEW PAGE
-------------------------------
Route: /admin/dividends (or similar)

Page Components:
1. Investor Selection Dropdown
2. Dividend Amount Input
3. Submit Button
4. Transaction Status Display

6.2 INVESTOR LIST FETCHING
---------------------------
Requirement: Fetch list of investors with email and wallet pubkey

Approach:
- Use React Query for data fetching
- Query backend API/database for investor records
- Filter for investors with ShareIssued investments (status = 4)
- Display format: "investor@email.com (8XLF...ieK)"

API Endpoint (to be created):
GET /api/admin/investors
Response: [
  {
    email: "investor@example.com",
    walletPubkey: "8XLFJExNrXT91Bz6ZdXfrBmicCCAY1U1UDSA7Vdi5ieK",
    investmentsPda: ["investmentPda1", "investmentPda2"],
    totalInvestment: 50000000000, // USDC smallest unit
    reitTokensOwned: 5000
  },
  ...
]

6.3 FORM STRUCTURE
------------------
```tsx
<Form>
  <Select
    label="Select Investor"
    options={investors}
    value={selectedInvestor}
    onChange={handleInvestorChange}
    renderOption={(inv) => `${inv.email} (${truncate(inv.walletPubkey)})`}
  />
  
  <NumberInput
    label="Dividend Amount (USDC)"
    value={dividendAmount}
    onChange={setDividendAmount}
    min={0}
    step={0.01}
    placeholder="Enter dividend amount"
  />
  
  <Select
    label="Related Investment"
    options={selectedInvestor?.investmentsPda}
    value={selectedInvestment}
    onChange={setSelectedInvestment}
    disabled={!selectedInvestor}
  />
  
  <Button
    onClick={handleSubmitDividend}
    disabled={!selectedInvestor || !dividendAmount || !selectedInvestment}
  >
    Issue Dividend
  </Button>
</Form>
```

6.4 TRANSACTION CONSTRUCTION
-----------------------------
Using generated Codama types:

```typescript
import { issueDividendsInstruction } from '@/generated/canadianreitinvest';

const handleSubmitDividend = async () => {
  // Convert USDC to smallest unit (6 decimals)
  const usdcSmallestUnit = dividendAmount * 1_000_000;
  
  // Get investment PDA (already selected from dropdown)
  const investmentPda = new PublicKey(selectedInvestment);
  
  // Fetch investment to get investor and fundraiser
  const investment = await program.account.investment.fetch(investmentPda);
  const investorPubkey = investment.investor;
  const fundraiserPda = investment.fundraiser;
  
  // Get or derive required accounts
  const adminPubkey = wallet.publicKey;
  const adminUsdcAta = getAssociatedTokenAddress(USDC_MINT, adminPubkey);
  const investorUsdcAta = getAssociatedTokenAddress(
    USDC_MINT, 
    investorPubkey
  );
  
  // Derive InvestmentDividendCounter PDA
  const [investmentDividendCounterPda] = PublicKey.findProgramAddressSync(
    [
      Buffer.from("investment_dividend_counter"),
      investmentPda.toBuffer()
    ],
    PROGRAM_ID
  );
  
  // Fetch or initialize counter to get current value
  let dividendCounter = 0;
  try {
    const counterAccount = await program.account.investmentDividendCounter.fetch(
      investmentDividendCounterPda
    );
    dividendCounter = counterAccount.dividendCounter.toNumber();
  } catch (e) {
    // Counter doesn't exist yet, will be initialized to 0
    dividendCounter = 0;
  }
  
  // Derive Dividend PDA with current counter value
  const [dividendPda] = PublicKey.findProgramAddressSync(
    [
      Buffer.from("dividend"),
      investmentPda.toBuffer(),
      Buffer.from(new Uint8Array(new BigUint64Array([BigInt(dividendCounter)]).buffer))
    ],
    PROGRAM_ID
  );
  
  // Build instruction
  const instruction = issueDividendsInstruction({
    admin: adminPubkey,
    adminUsdcAta,
    investment: investmentPda,
    investor: investorPubkey,
    investorUsdcAta,
    fundraiser: fundraiserPda,
    investmentDividendCounter: investmentDividendCounterPda,
    dividend: dividendPda,
    usdcMint: USDC_MINT,
    tokenProgram: TOKEN_PROGRAM_ID,
    systemProgram: SystemProgram.programId,
  }, {
    investmentPda: investmentPda,
    usdcAmount: usdcSmallestUnit,
  });
  
  // Send transaction
  const transaction = new Transaction().add(instruction);
  const signature = await sendTransaction(transaction, connection);
  await connection.confirmTransaction(signature);
  
  // Show success notification
  toast.success(`Dividend issued successfully! TX: ${signature}`);
};
```

CRITICAL CHANGES FROM ORIGINAL:
- Simplified parameters: Only investment_pda and usdc_amount needed
- Derive investor and fundraiser from investment (no need to pass separately)
- Use InvestmentDividendCounter PDA (per-investment, not global)
- Simpler PDA seeds: [b"dividend", investment_pda, counter]
- Fetch counter before deriving dividend PDA to get correct seed

6.5 UI/UX CONSIDERATIONS
------------------------
- Use Shadcn components for consistent design
- Display amounts in human-readable format (5.00 USDC, not 5000000)
- Show loading states during transaction
- Display transaction signature with Solana Explorer link
- Add confirmation modal before submission
- Validate admin has sufficient USDC balance before submitting
- Show previous dividend history for selected investor

================================================================================
7. BACKEND INTEGRATION NEEDS
================================================================================

7.1 DATABASE SCHEMA UPDATES
----------------------------
If using Supabase (as indicated in project structure):

Table: dividends_history
Columns:
- id: UUID (primary key)
- investor_email: TEXT
- investor_wallet: TEXT
- investment_pda: TEXT
- fundraiser_pda: TEXT
- usdc_amount: BIGINT (smallest unit)
- dividend_counter: INTEGER
- transaction_signature: TEXT
- issued_at: TIMESTAMP
- issued_by_admin: TEXT
- created_at: TIMESTAMP DEFAULT NOW()

Purpose: Off-chain record keeping, reporting, tax documents

7.2 API ENDPOINTS
-----------------
POST /api/admin/dividends/issue
- Validates admin authentication
- Constructs and sends transaction
- Records in database
- Returns transaction signature

GET /api/admin/dividends/history?investor=<pubkey>
- Fetches dividend history for investor
- Returns paginated results

GET /api/admin/investors
- Lists all investors with investment data
- Filters by investment status

7.3 WEBHOOK/LISTENER (Optional Enhancement)
--------------------------------------------
Listen for DividendsIssued events:
- Update database automatically
- Send email notifications to investors
- Trigger analytics updates

================================================================================
8. SECURITY CONSIDERATIONS
================================================================================

8.1 ATTACK VECTORS & MITIGATIONS
---------------------------------
✓ Unauthorized dividend issuance
  → Constraint: admin.key() == fundraiser.admin

✓ Double-spend of dividends
  → Unique PDA per counter value prevents re-initialization

✓ Dividend to wrong investor
  → Constraint validates investor matches investment.investor

✓ Incorrect investment association
  → Constraint validates investment.fundraiser == fundraiser

✓ Amount manipulation
  → Consider adding maximum dividend amount check
  → Consider checking admin ATA balance before transfer

✓ Front-running attacks
  → N/A - admin-only operation

✓ Reentrancy
  → Anchor framework provides protection
  → Transfer happens before PDA init (proper ordering)

8.2 RECOMMENDED ADDITIONAL CHECKS
----------------------------------
1. Add maximum dividend amount constraint (e.g., < 1,000,000 USDC)
2. Verify admin has sufficient USDC balance
3. Add time-based rate limiting (prevent spam)
4. Consider adding approval workflow (multi-sig for large amounts)

8.3 AUDIT CHECKLIST
-------------------
□ All account constraints properly defined
□ PDA seeds properly documented
□ Transfer uses transfer_checked (not transfer)
□ Decimal handling correct for USDC (6 decimals)
□ Event emission includes all relevant data
□ Error codes defined for all failure cases
□ Integration tests cover all scenarios
□ Admin-only actions properly gated

================================================================================
9. TESTING STRATEGY
================================================================================

9.1 UNIT TESTS (Anchor Tests)
------------------------------
Test File: anchor/tests/dividends.test.ts

Test Cases:
1. ✓ Successful dividend issuance
2. ✓ Unauthorized admin rejection
3. ✓ Invalid investor rejection
4. ✓ Mismatched investment rejection
5. ✓ Multiple dividends to same investor-investment
6. ✓ Correct USDC transfer amount
7. ✓ Event emission verification
8. ✓ Counter increment verification
9. ✗ Insufficient admin balance (should fail gracefully)
10. ✗ Invalid token accounts

9.2 INTEGRATION TESTS
---------------------
1. Full flow: invest → mint shares → issue dividend → verify balance
2. Multiple investors receiving dividends in same transaction batch
3. Frontend form submission → backend processing → on-chain confirmation

9.3 LOCALNET TESTING
--------------------
Prerequisites:
- USDC mint on localnet (see guide/USDC_LOCALNET_GUIDE.md)
- Admin wallet funded with USDC
- Test investor accounts with investments

Testing Script:
1. Deploy program to localnet
2. Initialize fundraiser
3. Create test investment
4. Mint REIT shares to investor
5. Issue dividend from admin
6. Verify investor USDC balance increased
7. Verify Dividends PDA created with correct data
8. Verify event emitted

================================================================================
10. IMPLEMENTATION SEQUENCE
================================================================================

10.1 PHASE 1: ONCHAIN PROGRAM (Anchor)
---------------------------------------
Step 1.1: Define state structures
  □ Create Dividends struct in state.rs
  □ Create DividendCounter struct
  □ Add to InitSpace derives

Step 1.2: Create instruction file
  □ Create anchor/programs/.../instructions/issue_dividends.rs
  □ Define IssueDividends accounts struct
  □ Implement handler function
  □ Add error codes to errors.rs

Step 1.3: Wire up in lib.rs
  □ Import instruction module
  □ Add pub fn issue_dividends entry point

Step 1.4: Add event definition
  □ Define DividendsIssued event
  □ Emit in handler after successful transfer

Step 1.5: Write tests
  □ Create test file
  □ Implement all test cases from section 9.1
  □ Run tests: cd anchor && anchor test

10.2 PHASE 2: CODAMA TYPE GENERATION
-------------------------------------
Step 2.1: Generate TypeScript types
  □ Build program: cd anchor && anchor build
  □ Generate types: npm run codama:js (from root, NOT anchor subfolder)
  □ Verify generated files in src/generated/

Step 2.2: Update frontend imports
  □ Import issueDividendsInstruction
  □ Import Dividends type definitions
  □ Add to barrel exports if needed

10.3 PHASE 3: BACKEND API
--------------------------
Step 3.1: Database migrations
  □ Create dividends_history table (if using Supabase)
  □ Add indexes for querying
  □ Test migrations

Step 3.2: API endpoints
  □ Implement POST /api/admin/dividends/issue
  □ Implement GET /api/admin/investors
  □ Implement GET /api/admin/dividends/history
  □ Add authentication middleware (admin-only)

Step 3.3: Integration utilities
  □ Create helper functions for PDA derivation
  □ Create helper for USDC amount conversion
  □ Add transaction construction utilities

10.4 PHASE 4: FRONTEND UI
--------------------------
Step 4.1: Create admin dividend page
  □ Create src/features/admin/dividends/
  □ Implement dividend-page.tsx
  □ Add route to app-routes.tsx

Step 4.2: Build form components
  □ Investor selection dropdown
  □ Investment selection dropdown (filtered by investor)
  □ Amount input with validation
  □ Submit button with loading state

Step 4.3: Implement transaction logic
  □ Account derivation functions
  □ Transaction construction
  □ Signature confirmation
  □ Error handling and user feedback

Step 4.4: Add history view
  □ Display past dividends for selected investor
  □ Format amounts correctly (6 decimal USDC)
  □ Link to Solana Explorer for each transaction

10.5 PHASE 5: TESTING & DEPLOYMENT
-----------------------------------
Step 5.1: Localnet testing
  □ Deploy to localnet
  □ Test full flow with script
  □ Verify frontend integration

Step 5.2: Devnet deployment
  □ Deploy program to devnet
  □ Fund admin wallet with devnet USDC
  □ Test with real wallets
  □ Monitor for issues

Step 5.3: Mainnet preparation
  □ Security audit review
  □ Load testing for concurrent dividends
  □ Backup and recovery procedures
  □ Admin training/documentation

Step 5.4: Mainnet deployment
  □ Deploy program to mainnet
  □ Verify program ID in frontend config
  □ Test with small amount first
  □ Monitor first few transactions closely

================================================================================
11. RISK ASSESSMENT
================================================================================

11.1 TECHNICAL RISKS
--------------------
RISK: PDA collision if counter not properly incremented
LIKELIHOOD: Low
MITIGATION: Atomic counter increment, comprehensive tests

RISK: USDC amount calculation errors (decimal handling)
LIKELIHOOD: Medium
MITIGATION: Extensive unit tests, UI validation, double-check logic

RISK: Admin wallet compromise leading to unauthorized dividends
LIKELIHOOD: Low
MITIGATION: Multi-sig wallet, hardware wallet, amount limits

RISK: Frontend/backend desync on account derivation
LIKELIHOOD: Medium
MITIGATION: Shared utility functions, integration tests

11.2 OPERATIONAL RISKS
----------------------
RISK: Distributing dividends to wrong investors
LIKELIHOOD: Low
MITIGATION: UI confirmation modal, preview before submit, audit logs

RISK: Incorrect dividend amounts
LIKELIHOOD: Medium
MITIGATION: Amount validation, preview, approval workflow for large amounts

RISK: Running out of admin USDC during batch distributions
LIKELIHOOD: Low
MITIGATION: Pre-flight balance check, error handling

11.3 COMPLIANCE RISKS
---------------------
RISK: Tax reporting for dividend distributions
LIKELIHOOD: High
MITIGATION: Comprehensive logging, export to CSV functionality

RISK: Regulatory requirements for dividend disclosures
LIKELIHOOD: Medium
MITIGATION: Consult legal counsel, maintain audit trail

================================================================================
12. FUTURE ENHANCEMENTS
================================================================================

12.1 BATCH DIVIDEND DISTRIBUTION
---------------------------------
Allow admin to issue dividends to multiple investors in single transaction
- Reduces transaction costs
- Faster distribution
- Requires careful PDA management

12.2 PROPORTIONAL DIVIDEND CALCULATION
---------------------------------------
Auto-calculate dividend per investor based on REIT token holdings
- Query all investors' token balances
- Calculate proportional distribution
- Generate transactions programmatically

12.3 SCHEDULED DIVIDENDS
-------------------------
Set up recurring dividend distributions
- Quarterly/monthly schedules
- Automated execution via keeper network
- Email notifications to investors

12.4 DIVIDEND REINVESTMENT
---------------------------
Allow investors to auto-reinvest dividends into more REIT tokens
- Optional flag on Investor PDA
- Direct purchase of additional shares
- Compound returns

12.5 MULTI-SIGNATURE APPROVAL
------------------------------
Require multiple admin approvals for large dividend amounts
- Squads Protocol integration
- Threshold-based triggers
- Enhanced security

================================================================================
13. DOCUMENTATION REQUIREMENTS
================================================================================

13.1 CODE DOCUMENTATION
-----------------------
□ Inline comments for complex logic
□ Function-level JSDoc/Rustdoc
□ Account structure documentation
□ PDA seed documentation
□ Error code descriptions

13.2 USER DOCUMENTATION
-----------------------
□ Admin guide: How to issue dividends
□ Investor guide: What to expect
□ FAQ: Common questions
□ Troubleshooting guide

13.3 DEVELOPER DOCUMENTATION
-----------------------------
□ Integration guide for frontend
□ API documentation
□ Event schema documentation
□ Testing guide

================================================================================
14. SUCCESS CRITERIA
================================================================================

Project will be considered successful when:

✓ Admin can issue USDC dividends to investors via UI
✓ Dividends are recorded on-chain with proper audit trail
✓ USDC transfers execute correctly (6 decimal handling)
✓ No duplicate dividends can be issued
✓ Only authorized admins can issue dividends
✓ Events are emitted for off-chain tracking
✓ All tests pass (unit, integration, e2e)
✓ Frontend UI is intuitive and error-free
✓ Database records match on-chain state
✓ Transaction confirmations visible to admin

Performance Benchmarks:
- Transaction confirmation: < 5 seconds
- UI responsiveness: < 200ms for interactions
- Database sync delay: < 10 seconds after transaction

================================================================================
15. DEPENDENCIES & PREREQUISITES
================================================================================

15.1 ONCHAIN DEPENDENCIES
--------------------------
□ Anchor Framework 0.30.x+
□ Solana Program Library (SPL Token)
□ USDC mint address (mainnet/devnet/localnet)

15.2 FRONTEND DEPENDENCIES
---------------------------
□ @solana/web3.js
□ @solana/wallet-adapter
□ React Query
□ Codama (for type generation)
□ Shadcn UI components

15.3 BACKEND DEPENDENCIES
--------------------------
□ Supabase client (if using)
□ Node.js runtime
□ TypeScript

15.4 INFRASTRUCTURE
-------------------
□ Solana RPC endpoint (Chainstack/QuickNode/etc)
□ Database for off-chain records
□ Admin wallet with USDC for distributions

================================================================================
16. SOLANA MCP EXPERT RECOMMENDATIONS INCORPORATED
================================================================================

From consultation with Solana MCP server:

✓ Use token_interface::transfer_checked (not transfer)
  → Ensures mint, decimals, and amount validation

✓ PDA seeds include investor, investment, and counter
  → Allows multiple dividends over time
  → Deterministic and collision-free

✓ Emit events for off-chain tracking
  → Include all relevant data points
  → Timestamp for ordering

✓ Authority checks via Anchor constraints
  → admin.key() == fundraiser.admin
  → Prevents unauthorized operations

✓ Separate PDAs per payout vs cumulative
  → Decision: Individual PDAs for audit trail
  → Trade-off accepted: More accounts vs better transparency

✓ Consider rate limiting and amount caps
  → Added to security recommendations
  → Prevents accidental large distributions

✓ Test decimal handling extensively
  → USDC has 6 decimals, not 9 like SOL
  → Critical for correct transfers

================================================================================
17. NOTES FROM SPEC REVIEW
================================================================================

SPEC ISSUES IDENTIFIED:
1. Schema in spec shows "pub struct Investment" but should be "pub struct Dividends"
   → Corrected in this plan

2. Missing "investment_pda" type annotation (should be Pubkey)
   → Added in PDA structure section

3. No mention of counter for multiple dividends
   → Added counter-based approach per MCP recommendations

4. Frontend fetching mechanism not detailed
   → Expanded with React Query and API structure

5. No guidance on USDC decimal handling
   → Added comprehensive section on amount conversion

SPEC ENHANCEMENTS MADE:
□ Added DividendCounter helper struct
□ Defined complete accounts structure
□ Added event emission
□ Detailed security checks
□ Expanded testing strategy
□ Added implementation phases
□ Included risk assessment

================================================================================
18. REVIEW & APPROVAL
================================================================================

This plan should be reviewed by:
□ Lead Developer (technical implementation)
□ Product Owner (feature requirements)
□ Security Auditor (security considerations)
□ Admin User (UI/UX usability)

Approval required before proceeding to implementation.

Approval Signatures:
_______________________  Date: __________
Lead Developer

_______________________  Date: __________
Product Owner

================================================================================
END OF IMPLEMENTATION PLAN
================================================================================

Document Version: 1.1 (UPDATED - Critical Architecture Fix)
Last Updated: October 27, 2025
Next Review: After Phase 1 completion

================================================================================
APPENDIX A: CRITICAL CHANGES FROM ORIGINAL SPEC (v1.0 → v1.1)
================================================================================

PROBLEM IDENTIFIED:
The original spec used a global DividendCounter PDA with seeds:
  [b"dividend_counter", investor_pubkey, investment_pda]

This had the same fundamental flaw as the investment_counter issue:
- If an investor has multiple investments, we cannot determine which counter 
  to use for which investment
- Counter would be global across all investments for that investor-investment pair
- Seeds were unnecessarily complex with redundant investor_pubkey

SOLUTION IMPLEMENTED:
Changed to per-investment counter with simpler seeds:
  InvestmentDividendCounter PDA: [b"investment_dividend_counter", investment_pda]
  Dividend PDA: [b"dividend", investment_pda, dividend_counter]

BENEFITS:
✓ Each investment has its own dividend counter (0, 1, 2...)
✓ No ambiguity when investor has multiple investments
✓ Simpler PDA derivation (investment_pda already encodes investor)
✓ Logical hierarchy: Investment → Dividends
✓ Matches the pattern used in InvestorFundraiser refactoring

KEY STRUCTURAL CHANGES:
1. Added InvestmentDividendCounter struct and PDA
2. Changed Dividend PDA seeds (removed investor_pubkey)
3. Simplified instruction parameters (only investment_pda + amount)
4. Updated frontend derivation logic
5. Updated event emission

RELATED REFACTORING:
This change parallels the investment_counter refactoring documented in:
  .github/spec/v1/tasks/investment-counter-refactor-plan.txt

Both refactorings solve the same architectural issue: using per-relationship
counters instead of global counters.

================================================================================
APPENDIX B: SOLANA MCP EXPERT VALIDATION
================================================================================

From Solana MCP consultation:

"Yes, a similar pattern for dividend tracking is recommended. Create a 
DividendCounter PDA:
  - DividendCounter PDA: [b"dividend_counter", investor_pubkey, investment_pda]
  - Fields: dividend_counter: u64

This approach provides the same benefits as the InvestorFundraiser PDA:
  - Per-Investment Tracking: Each investment has its own dividend counter
  - Scalability: You can track an unlimited number of dividends per investment
  - Deterministic Addresses: You can easily derive the address of any dividend 
    for a given investment"

NOTE: We further simplified from the MCP recommendation by removing investor_pubkey
from seeds since investment_pda already uniquely identifies the investor-investment
relationship.

For questions or clarifications, consult:
- Solana MCP server (for Solana/Anchor technical questions)
- .github/copilot-instructions.md (for project-specific context)
- anchor/programs/canadianreitinvest/src/ (for existing code patterns)
